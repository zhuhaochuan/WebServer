#### 版本1

实现了一个基于ＩＯ多路复用和线程池的简单的半同步半反应堆的web服务器。处理无状态的连接。

threadpool.h:
- 实现了一个基于阻塞队列的线程池　可以指定线程的数量已经任务队列当中最大的任务数量。
使用了泛型模板参数是实际的业务类，工作线程执行业务的ｐrocess方法。

main函数：
- 主线程使用epoll等待内核事件表当中的IO事件，监听本机ip端口的读写事件（是否有新用户建立连接），所有的已经连接的用户的文件描述的读写事件ＩＯ事件都由
主线程事件循环监管，将数据从用户缓冲区和内核缓冲区之间搬移。

http_conn类;
- 用户连接类，ｐrocess方法为工作线程调用的工作方法，没有任何IO操作，就是处理已经读好的用户响应和根据响应的返回码决定往用户写缓冲区写什么样的响应。
整个工作线程就是执行响应的业务逻辑。



####　几个关键的概念：

ＩＯ的同步和异步：同步ＩＯ是：ＩＯ的读写操作都是在ＩＯ事件发生之后由用户程序来完成。
异步ＩＯ：需要钙素内核用户的读写缓冲区，内核进行ＩＯ读写的操作。

同步ＩＯ实现的是Reactor模式：
主线程只负责监听文件描述符上是否有事件发生，有就立即通知工作线程。读写数据接受新的连接以及客户的请求都在工作线程上面完成。

半同步半异步模式：
同步线程处理客户逻辑，异步线程处理ＩＯ。

半同步半反应堆模式：
异步线程由主线程充当，负责监听ｓｏｃｋｅｔ上的事件，接受新的连接，往事件表当中注册该socket的读写事件，
如果socket上有读写事件发生就将其放入任务队列当中让工作线程去竞争获取。
采用Reactor模式：要求工作线程自己从socket上读取客户的数据。
采用模拟Proactor模式：由主线程完成数据的读写　，工作线程获取任务对象之后直接执行无需读写操作。
上述实现的服务器就是这个类型。


####　缺点;
主线程和工作线程共享请求队列，需要对队列的加锁保护，效率的损失。
工作线程有限，如果任务过多会导致任务堆积，响应变慢，如果增加线程的数目，线程的切换开销将加大。

#### LT和ＥＴ模式

epoll　对文件描述符的操作有两种模式，LT level　Ｔrigger电平触发　ET Edge Trigger边沿触发方式
电平触发是默认方式，此时相当于效率较高的poll，可以往内核事件当中注册一个文件描述符的EPOLLET事件此时是高效模式。
LT模式：epoll_wait上检测到其有事件发生的时候通知应用程序，应用程序可以不立即处理，这样当下次调用epoll_wait的时候还会通告此事件，直到被处理。
ET模式：检测到有事件发生就必须处理后续的调用不再通知这一事件，降低了重复触发次数。该模式下文件描述符的都应该是非阻塞的。





